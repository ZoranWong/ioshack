先看了《Unix环境高级编程》，想尝试一下自己用c实现一个ios上的游戏修改器。2013-05-25

首先要尝试从另外一个进程中读取目标进程的数据，最开始看网上用得比较多的是ptrace，卡了很久，才恍然大悟，os x的man page上面根本没有对PT_READ_D做定义，所以总是在执行ptrace（PT_READ_D，pid，NULL，NULL）的时候返回-1，errno是22.其实是自己用错了.2013-05-27

在网上偶然发现在osx和ios上是才用vm_read的方式，apple针对这个有一个叫Kernel Programming Guide的文档，先研究一下。2013-05-29.

发现Kernel Programming Guide文档里面讲的东西都非常概念，实际意义不大，但是又是运气好，搜了很多，在搜索osx vm_read关键字的时候，搜到一篇叫Abusing Mach on Mac OS X的文章，里面比较实际地讲解了如何在OS X上做修改内存和代码注入，依法为之，在我的mac上修改一个已知地址的进程变量成功（必须使用root用户），接下来就是研究如何在指定进程中搜索指定变量的工作了。2013-06-01-11:51.

搜索变量，初步指定在由mach_vm_region_recurse获得的vmoffset地址和GetBSDProcessList获得的userstack地址之间，但发现有时候vmoffset的地址会偏到一个很诡异的地方，卡主了一段时间，偶然在网上搜到Max OS X intervals这本书，里面提到vmmap命令，针对a.out进程查看了一下，好多之前不懂的问题都恍然大悟了，因为vmmap中清楚地打印了各个内存的地址范围了和类型，可见，很多地址即使在vm地址空间中也都是不连续的，所以需要研究一下怎么利用一个类似链表的东西，把所有地址串起来搜索。2013-06-02-3:37.

在完成地址空间的全部检索之前，试了一下之前的程序编译到ios平台，并且实际运行了一下，发现某些在os x上很轻松实现的事情到ios平台又会发生别的变数。为了方便调试，我决定先完成命令行的交互代码，这样就不用在代码中写死很多东西，来回折腾上传二进制文件，可以一次性调试多个情况。为了方便可以在不同地方进行，在github建立了一个开源项目，方便代码同步，其中，命令行交互的c代码，使用了一个开源的小程序，叫mio。2013-06-04-22:45.

交互代码完成得还比较顺利，但是发现mio不支持命令行中传一个64位16进制的地址，这部分得自己写一个，到时候给他发个pull request试试。
